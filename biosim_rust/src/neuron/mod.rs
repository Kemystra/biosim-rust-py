use std::cmp::Ordering;
use std::collections::HashMap;

pub mod internal_neuron;
pub mod action_neuron;
pub mod sensory_neuron;

use crate::genome::{Gene, Genome};
use sensory_neuron::{SensoryNeuron, TOTAL_SENSORY_NEURON_VARIANT};
use action_neuron::{ActionNeuron, TOTAL_ACTION_NEURON_VARIANT};
use internal_neuron::InternalNeuron;

pub type InternalNeuronID = usize;
const MAX_INTERNAL_NEURONS: usize = 3;

pub struct Brain {
    connections: Vec<Connection>,
    internal_neurons: Vec<InternalNeuron>,
}

impl Brain {
    pub fn from_genome(genome: &Genome) -> Self {
        let mut connections: Vec<Connection> = genome.genes()
            .iter()
            .map(|gene| Connection::from_gene(*gene))
            .collect();

        // Sorting the connections to ensure:
        // 1. Read SensoryNeuron
        // 2. Go through InternalNeuron
        // 3. Send to ActionNeuron
        // Direct Sensory-Action connections are executed immediately
        connections[..].sort_by(|a,b| a.connection_type.partial_cmp(&b.connection_type).unwrap());

        Brain {
            connections,
            internal_neurons: vec![InternalNeuron::new(); MAX_INTERNAL_NEURONS]
        }
    }
}

pub struct Connection {
    connection_type: ConnectionType,
    weight: f64,
}

impl Connection {
    pub fn from_gene(gene: Gene) -> Self {
        // Gene bit layout (from front):
        // bit 0-1 indicates ConnectionType
        // bit 2-6 indicates source ID
        // bit 7-11 indicates sink ID
        // bit 12-15 indicates weight, a 4-bit signed integer
        let conn_type_id = gene >> 14;
        let source_id = ((gene >> 9) & 32) as usize;
        let sink_id = ((gene >> 4) & 32) as usize;
        let weight: f64 = ((gene & 16) as i8 - 8).into();

        // This is kinda ugly, but it (might) work
        // Btw, should never EVER fail!
        let conn_type = match conn_type_id {
            0 => ConnectionType::SensoryToAction {
                source: SensoryNeuron::from_id(source_id % TOTAL_SENSORY_NEURON_VARIANT).unwrap(),
                sink: ActionNeuron::from_id(sink_id % TOTAL_ACTION_NEURON_VARIANT).unwrap()
            },

            1 => ConnectionType::SensoryToInternal {
                source: SensoryNeuron::from_id(source_id % TOTAL_SENSORY_NEURON_VARIANT).unwrap(),
                sink: sink_id % MAX_INTERNAL_NEURONS
            },

            2 => ConnectionType::InternalToInternal {
                source: source_id % MAX_INTERNAL_NEURONS,
                sink: sink_id % MAX_INTERNAL_NEURONS
            },

            3 => ConnectionType::InternalToAction {
                source: source_id % MAX_INTERNAL_NEURONS,
                sink: ActionNeuron::from_id(sink_id % TOTAL_ACTION_NEURON_VARIANT).unwrap()
            },

            _ => panic!("WTF happened here!")
        };

        Self {
            connection_type: conn_type,
            weight
        }
    }
}

#[derive(PartialEq)]
pub enum ConnectionType {
    SensoryToAction {source: SensoryNeuron, sink: ActionNeuron},
    SensoryToInternal {source: SensoryNeuron, sink: InternalNeuronID},
    InternalToInternal {source: InternalNeuronID, sink: InternalNeuronID},
    InternalToAction {source: InternalNeuronID, sink: ActionNeuron},
}

// Ugly stuff generated by chatGPT bitches
// No, I don't want to make yet another macro for this
impl PartialOrd for ConnectionType {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        use Ordering::{Less, Equal, Greater};
        use ConnectionType::*;

        match (self, other) {
            (SensoryToAction {..}, SensoryToAction {..}) => Some(Equal),
            (SensoryToAction {..}, _) => Some(Less),

            (SensoryToInternal {..}, SensoryToAction {..}) => Some(Greater),
            (SensoryToInternal {..}, SensoryToInternal {..}) => Some(Equal),
            (SensoryToInternal {..}, _) => Some(Less),

            (InternalToInternal {..}, InternalToAction {..}) => Some(Less),
            (InternalToInternal {..}, InternalToInternal {..}) => Some(Equal),
            (InternalToInternal {..}, _) => Some(Greater),

            (InternalToAction {..}, InternalToAction {..}) => Some(Equal),
            (InternalToAction {..}, _) => Some(Greater),
        }
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use biosim_rust_macros::enum_from_id;

    #[enum_from_id]
    #[derive(Debug, PartialEq)]
    enum MyEnum {
        VariantA,
        VariantB,
        VariantC,
    }

    #[test]
    fn test_enum_from_id() {
        // Use the generated from_id function to get enum variants
        let variant_a = MyEnum::from_id(0);
        let variant_b = MyEnum::from_id(1);
        let variant_c = MyEnum::from_id(2);

        // Assert that the variants are as expected
        assert_eq!(variant_a, Some(MyEnum::VariantA));
        assert_eq!(variant_b, Some(MyEnum::VariantB));
        assert_eq!(variant_c, Some(MyEnum::VariantC));

        // Test with an out-of-range ID, should return None
        let out_of_range = MyEnum::from_id(10);
        assert_eq!(out_of_range, None);
    }

    #[test]
    fn test_connection_type_partial_ord() {
        let conn1 = ConnectionType::SensoryToAction {
            source: SensoryNeuron::DistToBarrierEast,
            sink: ActionNeuron::MoveEast
        };

        let conn2 = ConnectionType::SensoryToInternal {
            source: SensoryNeuron::DistToBarrierEast,
            sink: 10
        };

        let conn3 = ConnectionType::InternalToInternal {
            source: 2,
            sink: 4
        };

        let conn4 = ConnectionType::InternalToAction {
            source: 9,
            sink: ActionNeuron::MoveEast
        };

        assert!(conn1 < conn2);
        assert!(conn2 < conn3);
        assert!(conn3 < conn4);
    }
}
